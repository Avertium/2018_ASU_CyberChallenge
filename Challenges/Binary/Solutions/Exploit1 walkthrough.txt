01_Buffering Walkthrough

Looking at the code, we are given a integer (modified) and a character buffer (buffer). 'Modified' is then set to Zero. Later in the code, if 'modified' is anything but Zero, we win! Otherwise, we are told to try again. If we are to look at how these are pushed onto the stack memory, they would go in this order:

Name          | Mem Address
--------------|-------------
buffer[128] --| 0x80 - 0x04
modified -----| 0x00 - 0x03

[ buffer (128 bytes) ][ modified (4 bytes) ]



This may seem backwards, because the stack grows from a lower memory address, to a higher memory address. 

The gets() function is used to read from standard input (stdin), into the character buffer: 'buffer'. Now the character buffer is only set to hold 128 bytes, however, the gets() function does not know this. Therefore, we can exploit the gets() function to write more than 128 bytes. For example, if we write 132 bytes, we will overflow the value of modified with the 4 extra bytes that the program tried to put into 'buffer'. This can be shown here:

 buffer        modified
[ 'A' * 128 ] [ 'AAAA' ] 

There are two ways to do this in practice: The first way is to run the program and hold down 'A', or any character key, long enough to enter more than 128 bytes into the buffer. The second is to use python or perl to write these characters for you.

$ python -c 'print "A" * 132' | ./exploit1
Flag: Baby5F1r5t0verflow