03_Dumping_The_Key Walkthrough

This challenge is very similar to exploit1 in that it has the same buffer overflow with gets(), but also like exploit2 in that it also requires a variable to be overwritten with a specific value.

Looking at the code, we are given a integer pointer (*win) and a character buffer (buffer). 'win' is then set to Zero. Later in the code, if 'win' has a value, it will call the address of that function. If we are to look at how these are pushed onto the stack memory, they would go in this order:

Name          | Mem Address
--------------|-------------
buffer[128] --| 0x80 - 0x04
*win -----| 0x00 - 0x03

[ buffer (128 bytes) ][ *win (4 bytes) ]



This may seem backwards, because the stack grows from a lower memory address, to a higher memory address. 

The gets() function is used to read from standard input (stdin), into the character buffer: 'buffer'. Now the character buffer is only set to hold 128 bytes, however, the gets() function does not know this. Therefore, we can exploit the gets() function to write more than 128 bytes. For example, if we write 132 bytes, we will overflow the value of modified with the 4 extra bytes that the program tried to put into 'buffer'. This can be shown here:

 buffer        *win
[ 'A' * 128 ] [ 'AAAA' ] 


To exploit this, we first need to find the function address for win(). This can be done using objdump or gdb:
$ objdump -D ./exploit3 | grep win.:
004011d0 <_win>:

$ gdb ./exploit3 -q
(gdb) print win
$1 = {<text variable, no debug info>} 0x4011d0 <win>

Now that we know the address for win(), we can do the same thing as exploit2 and overwrite the function pointer '*win'.

$ python -c 'print "A" * 128 + "\xd0\x11\x40\x00' | ./exploit3
Flag: N0wUR1337H4ck3r