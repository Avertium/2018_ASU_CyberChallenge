02_Cowboys_And_Endians Walkthrough

This challenge is very similar to the first exploit challenge. Looking at the code, we are given a integer (modified) and a character buffer (buffer). 'Modified' is then set to Zero. This time, however, 'modified' needs to be changed to a specific value. Otherwise, we are told to try again. If we are to look at how these are pushed onto the stack memory, they would go in this order:

Name          | Mem Address
--------------|-------------
buffer[128] --| 0x80 - 0x04
modified -----| 0x00 - 0x03

[ buffer (128 bytes) ][ modified (4 bytes) ]



This may seem backwards, because the stack grows from a lower memory address, to a higher memory address. 

The strcpy() function is used to read from one buffer, into the character buffer: 'buffer'. Now the character buffer is only set to hold 128 bytes, however, like the gets() function, the strcpy() function does not know this. Therefore, we can exploit the strcpy() function in the same way to write more than 128 bytes. For example, if we write 132 bytes, we will overflow the value of modified with the 4 extra bytes that the program tried to put into 'buffer'. This can be shown here:

 buffer        modified
[ 'A' * 128 ] [ 'AAAA' ] 

That would be too easy. This time, we need to change the characters for 'modified' to 0x71727374. There's something special here. Intel uses what's called 'little endian'. To oversimplify, this means the bytes are put in backwards from how we would read them. That for 0x71727374 to be human readable, we would have to look at those bytes individually as 0x74 0x73 0x72 0x71.

(Fun fact, these are the characters 'tsrq' in ASCII)

To solve this with python, we need to change the way we input this information since it's looking for an argument:
$ ./exploit2 $(python -c 'print "A" * 128 + "\x74\x73\x72\x71')
Flag: G3tt1ngSm4rter
